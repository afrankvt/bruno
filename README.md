# BrunoDB

[fan]: http://fantom.org

Bruno is a key-value store written in pure [Fantom][fan].

Keys are internally assigned auto-incrementing integers, and values are
name-value pair records. Records are stored under buckets, where ids are unique
within a bucket.

Licensed under the MIT license.

## Features

 * Designed for non-distributed single server applications
 * Optimized for Fantom immutability and concurrency
 * Runs in-process with your Fantom application
 * Fast zero-copy concurrent access
 * Durable commit log storage design
 * Buckets for one-level of record organization
 * Support for most Fantom value types

## Examples

TODO

## Benchmarks

The results below were generated by the `PerfTest` tool, which is included in
Bruno. To run these tests yourself:

    $ fan bruno::PerfTest

Test machine:

  * MacBook Pro (Retina, 15-inch, Mid 2015)
  * 2.8 GHz Intel Core i7
  * 16 GB 1600 MHz DDR3
  * 500GB Flash Storage

TODO

## Technical Notes

[fan-actor]: http://fantom.org/doc/docLang/Actors
[per-ds]:    https://en.wikipedia.org/wiki/Persistent_data_structure

The primary goal for Bruno was to create a simple but fast and reliable
datastore specifically designed in and for [Fantom][fan] and Fantom's [Actor
concurrency model][fan-actor].

Bruno is designed to keep all records in memory, and as such is intentionally
targeted to run on a single host. There is currently no support or plans to
support replication, distribution, etc.

**Persistent Maps**

One of the key challenges with a Fantom-based database is sharing our mutable
record data across Actors. Bruno uses the concept of [Persistent data
structures][per-ds] to efficiently share immutable snapshots of record maps,
approximating the performance and benefits of shared memory access.

**Storage**

Since all records are cached in memory, the storage layer uses a very simple
log-structured merge (LSM) algorithm. Modifications are written to an
append-only commit log. Once a threshold has been reached, or the database is
closed, the active log segment is closed and becomes immutable. A new active
segment is then opened for writes. A background actor will periodically merge
the closed segments to reclaim disk space.